#!/bin/sh

USARTs="0 1 2 3"

template="
//
// USARTnnn
//
#if HAVE_UARTnnn
static uart_port_t *uartnnn_port;

ISR(USARTnnn_RXC_vect) {
	// Set RXSIF bit to '1' to clear it
	USARTnnn.STATUS = USART_RXSIF_bm | USART_ISFIF_bm;

	if (BIT_IS_SET(USARTnnn.STATUS, USART_RXCIF_bm)) {
		UARTx_RXC_IRQHandler(uartnnn_port);
	}
}
#endif
"

cat << EOF
//
// Generated by ${0} on $(date)
//

#if ENABLE_UART_LISTENING

#define ASSIGN_IRQ_PORT(_irqn_, _p_) do { uart ## _irqn_ ## _port = (_p_); } while (0);

static void UARTx_RXC_IRQHandler(uart_port_t *p) {
#if UART_INPUT_BUFFER_BYTES > 0
	if (p->rx_buf.bytes < UART_INPUT_BUFFER_BYTES) {
		p->rx_buf.buffer[p->rx_buf.bytes] = p->uartx->RXDATAL;
		++p->rx_buf.bytes;
	} else
#endif
	{
		// We still need to read the byte or else we'll just immediately re-enter
		// this interrupt
		uint8_t rx = p->uartx->RXDATAL;
		UNUSED(rx);
	}

	uart_rx_irq_hook(p);

	return;
}
EOF

for u in ${USARTs}; do
	printf "%s" "${template}" | sed -e "s|nnn|${u}|g"
done

cat << EOF
#else // ENABLE_UART_LISTENING
#define ASSIGN_IRQ_PORT(_irqn_, _p_) ((void )0U)

#endif // ENABLE_UART_LISTENING
EOF
