#!/bin/bash

# The clock sources are the core clock, the core clock divided by 2, or the
# prescaled TCA clock. We don't test the TCA clock because
#    1. We don't know what it is
#    2. It may change
# The clock sources must be listed in the order of their representation in
# the CLKSEL bits of CTRLA
clock_sources=( "(TIMER_CLOCK)" "(TIMER_CLOCK/2U)" )

preamble() {
	cat << EOF
//
// Generated by ${0} on $(date)
//
// This script requires the following macros to be set:
//    TIMER_CLOCK: The base clock rate of the timer
//    TIMER_HZ   : The desired frequency of the timer signal
//    COUNTER_MAX: The maximum value of the timer's counter
//
// This script sets the following macros:
//    TIMER_TOP  : The value of the timer's PER register
//    TIMER_SRC  : The value of the CLKSEL bits in the timer's CTRLA register
//    TIMER_ERROR: The difference between the frequency given by the selected
//                 values and the desired frequency
//
#undef DONE
#undef TIMER_ERROR

#define TIMER_ERROR (TIMER_HZ)


#if (TIMER_CLOCK / TIMER_HZ) < 1
# error "Unable to calculate timer values, input clock too slow"
# define DONE 1
#endif
EOF
}

test_body() {
	SRC="${1}"
	REG="${2}"

	cat << EOF

#if !defined(DONE)
# undef TEST_MOD
# undef TEST_DIV
# define TEST_MOD (${SRC} % TIMER_HZ)
# define TEST_DIV (${SRC} / TIMER_HZ)
# if TEST_DIV > 0 && TEST_DIV <= COUNTER_MAX + 1
#  if TEST_MOD == 0
#   define DONE 1
#  endif
#  if TEST_MOD < TIMER_ERROR
#   undef TIMER_ERROR
#   undef TIMER_SRC
#   undef TIMER_TOP
#   define TIMER_ERROR (${SRC} % TIMER_HZ)
#   define TIMER_SRC ((uint8_t )${REG} << TCB_CLKSEL_gp)
#   define TIMER_TOP ((${SRC} / TIMER_HZ) - 1U)
#  endif
# endif
#endif
EOF
}

postamble() {
	cat << EOF

#if TIMER_ERROR == TIMER_HZ
# error "Unable to calculate timer values, input clock likely too fast"
#endif
#undef DONE
#undef TEST_MOD
#undef TEST_DIV
EOF
}

preamble
i=0
for src in ${clock_sources[@]}; do
	test_body "${src}" "${i}"
	((i+=1))
done
postamble
