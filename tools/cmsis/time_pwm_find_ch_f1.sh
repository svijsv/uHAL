#!/bin/sh

timers="1 2 3 4 5 8 9 10 11 12 13 14"
timers_4ch="1 2 3 4 5 8"
timers_2ch="9 12"
timers_1ch="10 11 13 14"

template_4ch="
//
// Timer NNN
#if USE_TIMERNNN_PWM
	case PINID_TIMNNN_CH1:
		--ch;
# if defined(PINID_TIMNNN_CH2) && PINID_TIMNNN_CH2 > 0
		// fall through
	case PINID_TIMNNN_CH2:
# endif
		--ch;
# if defined(PINID_TIMNNN_CH3) && PINID_TIMNNN_CH3 > 0
		// fall through
	case PINID_TIMNNN_CH3:
# endif
		--ch;
# if defined(PINID_TIMNNN_CH4) && PINID_TIMNNN_CH4 > 0
		// fall through
	case PINID_TIMNNN_CH4:
# endif
		t = TIMER_NNN;
		TIMx = TIMNNN;
		TIMxEN = RCC_PERIPH_TIMNNN;
		break;
#endif // USE_TIMERNNN_PWM
"

template_2ch="
//
// Timer NNN
#if USE_TIMERNNN_PWM
	case PINID_TIMNNN_CH1:
		--ch;
		// fall through
	case PINID_TIMNNN_CH2:
		ch -= 2;
		t = TIMER_NNN;
		TIMx = TIMNNN;
		TIMxEN = RCC_PERIPH_TIMNNN;
		break;
#endif // USE_TIMERNNN_PWM
"

template_1ch="
//
// Timer NNN
#if USE_TIMERNNN_PWM
	case PINID_TIMNNN_CH1:
		t = TIMER_NNN;
		TIMx = TIMNNN;
		TIMxEN = RCC_PERIPH_TIMNNN;
		ch = 1;
		break;
#endif // USE_TIMERNNN_PWM
"

cat << EOF
//
// Generated by ${0} on $(date)
//


static TIM_TypeDef* find_available_pin_pwm_tim(gpio_pin_t pin, uint_fast8_t *tim_id, uint_fast8_t *channel, gpio_af_t *af_code, rcc_periph_t *rcc) {
	uint_fast8_t ch = 4, t;
	rcc_periph_t TIMxEN = 0;
	TIM_TypeDef *TIMx = NULL;

	switch (PINID(pin)) {

//
// 4-Channel PWM timers
//
EOF

cat >>/dev/null <<SUPEREOF
for t in ${timers_4ch}; do
	printf "%s" "${template_4ch}" | sed -e "s|NNN|${t}|g"
done

cat <<- EOF

//
// 2-Channel PWM timers
//
EOF
for t in ${timers_2ch}; do
	printf "%s" "${template_2ch}" | sed -e "s|NNN|${t}|g"
done

cat <<- EOF

//
// 1-Channel PWM timers
//
EOF
for t in ${timers_1ch}; do
	printf "%s" "${template_1ch}" | sed -e "s|NNN|${t}|g"
done
SUPEREOF

for t in ${timers}; do
	printf "%s" "${template_4ch}" | sed -e "s|NNN|${t}|g"
done


cat << EOF

	default:
		return NULL;
	}

#if ! uHAL_SKIP_OTHER_CHECKS
	uint32_t enr_bit;

	switch (ch) {
	case 1:
		enr_bit = TIM_CCER_CC1E;
		break;
	case 2:
		enr_bit = TIM_CCER_CC2E;
		break;
	case 3:
		enr_bit = TIM_CCER_CC3E;
		break;
	//case 4:
	default:
		enr_bit = TIM_CCER_CC4E;
		break;
	}
	// FIXME: Look for an alternative timer instead
	if (BIT_IS_SET(TIMx->CCER, enr_bit)) {
		return NULL;
	}
#endif

	if (tim_id != NULL) {
		*tim_id = t;
	}
	if (channel != NULL) {
		*channel = ch;
	}
	if (af_code != NULL) {
		*af_code = 0;
	}
	if (rcc != NULL) {
		*rcc = TIMxEN;
	}
	return TIMx;
}
EOF
