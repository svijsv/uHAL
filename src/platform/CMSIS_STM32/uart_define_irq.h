//
// Generated by tools/cmsis/uart_define_irq.sh on Thu Aug  8 06:39:17 PM EDT 2024
//

#if ENABLE_UART_LISTENING

#define ASSIGN_IRQ_PORT(_irqn_, _p_) do { uart ## _irqn_ ## _port = (_p_); } while (0);

static void UARTx_RXNE_IRQHandler(uart_port_t *p) {
#if UART_INPUT_BUFFER_BYTES > 0
	if (p->rx_buf.bytes < UART_INPUT_BUFFER_BYTES) {
		p->rx_buf.buffer[p->rx_buf.bytes] = p->uartx->DR;
		++p->rx_buf.bytes;
	} else
#endif // UART_INPUT_BUFFER_BYTES > 0
	{
		// We still need to read the byte or else we'll just immediately re-enter
		// this interrupt
		uint8_t rx = p->uartx->DR;
		UNUSED(rx);
	}
	//
	// By doing this instead, we can tell if we missed anything by checking if bytes > UART_INPUT_BUFFER_BYTES
	//p->rx_buf.buffer[p->rx_buf.bytes % UART_INPUT_BUFFER_BYTES] = p->uartx->DR;
	//++p->rx_buf.bytes;

	//NVIC_DisableIRQ(p->irqn);
	NVIC_ClearPendingIRQ(p->irqn);

	return;
}


//
// USART1
//
#if HAVE_UART1
static uart_port_t *uart1_port;
//__attribute__((weak))
void USART1_IRQHandler(void) {
	if (BIT_IS_SET(uart1_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart1_port);
		uart_rx_irq_hook(uart1_port);
	}

	return;
}
#endif // HAVE_UART1

//
// USART2
//
#if HAVE_UART2
static uart_port_t *uart2_port;
//__attribute__((weak))
void USART2_IRQHandler(void) {
	if (BIT_IS_SET(uart2_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart2_port);
		uart_rx_irq_hook(uart2_port);
	}

	return;
}
#endif // HAVE_UART2

//
// USART3
//
#if HAVE_UART3
static uart_port_t *uart3_port;
//__attribute__((weak))
void USART3_IRQHandler(void) {
	if (BIT_IS_SET(uart3_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart3_port);
		uart_rx_irq_hook(uart3_port);
	}

	return;
}
#endif // HAVE_UART3

//
// USART6
//
#if HAVE_UART6
static uart_port_t *uart6_port;
//__attribute__((weak))
void USART6_IRQHandler(void) {
	if (BIT_IS_SET(uart6_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart6_port);
		uart_rx_irq_hook(uart6_port);
	}

	return;
}
#endif // HAVE_UART6

//
// UART4
//
#if HAVE_UART4
static uart_port_t *uart4_port;
//__attribute__((weak))
void UART4_IRQHandler(void) {
	if (BIT_IS_SET(uart4_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart4_port);
		uart_rx_irq_hook(uart4_port);
	}

	return;
}
#endif // HAVE_UART4

//
// UART5
//
#if HAVE_UART5
static uart_port_t *uart5_port;
//__attribute__((weak))
void UART5_IRQHandler(void) {
	if (BIT_IS_SET(uart5_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart5_port);
		uart_rx_irq_hook(uart5_port);
	}

	return;
}
#endif // HAVE_UART5

//
// UART7
//
#if HAVE_UART7
static uart_port_t *uart7_port;
//__attribute__((weak))
void UART7_IRQHandler(void) {
	if (BIT_IS_SET(uart7_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart7_port);
		uart_rx_irq_hook(uart7_port);
	}

	return;
}
#endif // HAVE_UART7

//
// UART8
//
#if HAVE_UART8
static uart_port_t *uart8_port;
//__attribute__((weak))
void UART8_IRQHandler(void) {
	if (BIT_IS_SET(uart8_port->uartx->SR, USART_SR_RXNE)) {
		UARTx_RXNE_IRQHandler(uart8_port);
		uart_rx_irq_hook(uart8_port);
	}

	return;
}
#endif // HAVE_UART8

#else // ENABLE_UART_LISTENING
#define ASSIGN_IRQ_PORT(_irqn_, _p_) ((void )0U)

#endif // ENABLE_UART_LISTENING
