//
// Generated by tools/xmega3/uart_define_irq.sh on Fri Jul 26 03:53:43 AM EDT 2024
//

#if ENABLE_UART_LISTENING

#define ASSIGN_IRQ_PORT(_irqn_, _p_) do { uart ## _irqn_ ## _port = (_p_); } while (0);

static void UARTx_RXC_IRQHandler(uart_port_t *p) {
#if UART_INPUT_BUFFER_BYTES > 0
	if (p->rx_buf.bytes < UART_INPUT_BUFFER_BYTES) {
		p->rx_buf.buffer[p->rx_buf.bytes] = p->uartx->RXDATAL;
		++p->rx_buf.bytes;
	} else
#endif
	{
		// We still need to read the byte or else we'll just immediately re-enter
		// this interrupt
		uint8_t rx = p->uartx->RXDATAL;
		UNUSED(rx);
	}

	uart_rx_irq_hook(p);

	return;
}

//
// USART0
//
#if HAVE_UART0
static uart_port_t *uart0_port;

ISR(USART0_RXC_vect) {
	// Set RXSIF bit to '1' to clear it
	USART0.STATUS = USART_RXSIF_bm | USART_ISFIF_bm;

	if (BIT_IS_SET(USART0.STATUS, USART_RXCIF_bm)) {
		UARTx_RXC_IRQHandler(uart0_port);
	}
}
#endif

//
// USART1
//
#if HAVE_UART1
static uart_port_t *uart1_port;

ISR(USART1_RXC_vect) {
	// Set RXSIF bit to '1' to clear it
	USART1.STATUS = USART_RXSIF_bm | USART_ISFIF_bm;

	if (BIT_IS_SET(USART1.STATUS, USART_RXCIF_bm)) {
		UARTx_RXC_IRQHandler(uart1_port);
	}
}
#endif

//
// USART2
//
#if HAVE_UART2
static uart_port_t *uart2_port;

ISR(USART2_RXC_vect) {
	// Set RXSIF bit to '1' to clear it
	USART2.STATUS = USART_RXSIF_bm | USART_ISFIF_bm;

	if (BIT_IS_SET(USART2.STATUS, USART_RXCIF_bm)) {
		UARTx_RXC_IRQHandler(uart2_port);
	}
}
#endif

//
// USART3
//
#if HAVE_UART3
static uart_port_t *uart3_port;

ISR(USART3_RXC_vect) {
	// Set RXSIF bit to '1' to clear it
	USART3.STATUS = USART_RXSIF_bm | USART_ISFIF_bm;

	if (BIT_IS_SET(USART3.STATUS, USART_RXCIF_bm)) {
		UARTx_RXC_IRQHandler(uart3_port);
	}
}
#endif
#else // ENABLE_UART_LISTENING
#define ASSIGN_IRQ_PORT(_irqn_, _p_) ((void )0U)

#endif // ENABLE_UART_LISTENING
